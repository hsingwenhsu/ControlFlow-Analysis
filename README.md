# COMS W4115: Final Project Task 1: Unreachable Function Identification and Elimination with Control Flow Analysis

## Course Summary

Course: COMS 4115 Programming Languages and Translators (Fall 2021)  
University: Columbia University.  
Instructor: Prof. Baishakhi Ray


## Logistics
* **Announcement Date:** Monday, November 29, 2021
* **Due Date:** Monday, December 20, 2021 by 11:59 PM.
* **Total Points:** 100



## Unreachable Function Identification and Elimination with Control Flow Analysis

In class and in previous programming assignments, we learned about __control flow analysis__. In this assignment, we will use such analysis techniques to optimize code. Particularly in this task, you will design a tool to remove the unnecessary functions that will never not be executed.

As you might already notice in your software development practice, human developers tend to keep some unreachable functions in the source code for a long time. In some cases, developers tend to keep some unreachable helper functions in the program as a backup and sometimes they forget to remove all outdated functions. All these functions will not be executed by the machine, and your task is to identify such functions and remove them.   

We assume that every program will have an entry function (in C, this is typically `main`). Consider the following program:

```c++
 1. int add(int n, int m) {
 2.     return n + m;
 3. }
 4. int mult(int m, int n) {
 5.     int res = 0, t = 5, x = m * n;
 6.     while(res != x) {
 7.         res = res + m;
 8.     }
 9.     return res;
10. }
11. int fact(int n) {
12.     if (n == 0) return 1;
13.     else {
14.         return mult(n, fact(add(n, -1)));
15.     }
16. }
17. int main() {
18.     int n = 9, m = 8;
19.     print(mult(m, n));
20.     return 0;
21. }
```  

Here, the entry function is `main`. Among the other functions, `fact` and `add` are never executed when starting from `main`. Thus, our objective for this optimization is to remove such functions that are never used or considered *unreachable* or *dead* in the code.

To begin identifying unreachable functions, we need to extract and analyze a [call graph](https://en.wikipedia.org/wiki/Call_graph). A call graph is a graph that shows the relationships among direct function calls in a program. Every node of a call graph represents a function call, and an edge from a node `A` to a node `B` in the call graph indicates that function `B` is invoked by function `A`, *i.e.*, a function call to `B` is made inside of function `A`'s body. Note that analyzing indirect function calls through function pointers requires a more sophisticated analysis technique, so for simplicity, assume that all function calls are direct function calls.

Once we identify all functions that are never called starting from `main`, our objective is to remove those from the code.

### Getting Started

1. Convert the `example.c` C program (from the `examples` directory) to an IR by running the following, just as you did in the previous assignment:

```
export LLVM_HOME="<the absolute path to llvm-project>";
export PATH="$LLVM_HOME/build/bin:$PATH";

clang -O0 -Xclang -disable-O0-optnone -emit-llvm -c example.c
llvm-dis example.bc
```
You have now generated an `example.bc` file, which contains the IR in binary format. You will also see an `example.ll` file, which contains the IR in human-readable format.

2. Convert the `example.bc` file to single static assignment form (this is very important for generating suitable inputs, so please do not forget to perform this step):

```
opt -mem2reg example.bc -o ssa.bc
llvm-dis ssa.bc
```

Note that the `ssa.ll` file that is created will be the input for this assignment.

3. Create a directory `clang-final-1` in `$LLVM_HOME/llvm/lib/Transforms` for this assignment, and copy the files from the `src` directory to this new directory, as follows:

```
cp -r ./src/ "$LLVM_HOME/llvm/lib/Transforms/clang-final-1/"
```

4. Append `add_subdirectory(clang-final-1)` to the `$LLVM_HOME/llvm/lib/Transforms/CMakeLists.txt` file.

5. Build `clang-final-1` by running the following commands:

```
cd "$LLVM_HOME/build"
make
```

After you successfully run `make` once, you can rebuild the project using `make LLVMOptimizer`.

6. Whenever you are running the pass for this assignment, please run the following command:

```
opt -load $LLVM_HOME/build/lib/LLVMOptimizer.so -optimize ssa.bc
```

Read through the output you see in the terminal for additional hints. Additionally, take a look at the different files generated by the pass. 

We are implementing a [`ModulePass`](https://llvm.org/doxygen/classllvm_1_1ModulePass.html) in this assignment. [`runOnModule`](src/dead-function-analyzer.cpp#L94) is the entry point for the pass, much like `runOnFunction` was the entry point for the `FunctionPass`. In `runOnModule` function, we extracted for you [`allFunctions`](src/dead-function-analyzer.cpp#L96-#99) (a vector of all the functions) and [entryFunction](src/dead-function-analyzer.cpp#L102) (the entry function) structures. We have also taken care of all the inputs and outputs.

### Task 1: Identification of Dead Functions
In this task, you will first implement the [`getCallGraph`](src/dead-function-analyzer.cpp#L43) to extract the call graph. This function takes a vector of `Function *` containing all the functions in the current Module, and you need to create a hash map (a common way to store graph structure) for the call graph. You will then implement  the [`getDeadFunctions`](src/dead-function-analyzer.cpp#L66) function and return a vector of `Function *` denoting the unreachable/dead functions (_i.e._, functions that are not reachable from `main`). This function takes in a `vector<Function *>` containing all functions in the module, `map<Function *, vector<Function *>>` containing the call graph, and a `Function *` indication the pointer to the entry function. The `TODO` comment also summarizes what needs to be done.

### Task 2: Removal of Dead Functions
Once you find all the dead functions, you will implement the [`removeDeadFunctions`](src/dead-function-analyzer.cpp#L80) function to actually perform the removal of all these dead functions. Note that our definition of "dead" _does NOT mean_ a function is not called from anywhere in the code. It simply refers to the fact that a function is not reachable from `main`. Thus, while you are removing a dead function, make sure that you properly update any possible call sites of that function. Given this hint, you will probably need to do some research to find suitable APIs to accomplish this task.
  

### Important Notes
1. Please **DO NOT** remove or modify any of the existing code.
2. Place all of your code in the sections that we have outlined for you. You may include helper functions as necessary, but please make sure to put them inside the [`src/dead-function-analyzer.cpp`](src/dead-function-analyzer.cpp) file as necessary. Keep in mind that we will only use this file from your submission for grading. 
3. Carefully read through the steps highlighted in this README, as well as the TODOs and other comments in the code. You will find useful hints.
4. Once you successfully run the pass, you will notice that the `ssa-modified.ll` file should reflect your optimizations. Compare your original `ssa.ll` file with the `ssa-modified.ll` file to see the output of your compiler optimizations.

## Submission
We will only consider [`src/dead-function-analyzer.cpp`](src/dead-function-analyzer.cpp) from your submission. Please make sure all relevant code is **only** in this file. Make sure to properly commit your code and push it to the `main` branch.


## Disclaimer
This assignment belongs to Columbia University. It may be freely used for educational purposes.
